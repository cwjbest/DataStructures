1. mysql的存储引擎有哪几种？ 111
   InnoDB:支持事务，行级锁，外键
   Myisam:查询速度快，表级锁，有表的行数，count快

3. 脏读？幻读？ 111
4. 数据库索引原理， Hash，B+树，LSM树； 111
   LSM树：牺牲读性能，换取写性能
17.数据库隔离等级 111
5. MVCC 多版本并发控制，来解决读写锁的冲突，写的时候会创建一个新的版本，读的时候读最新的那个版本

   多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，
   为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。
   这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读

   乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，认为事务间争用没有那么多，所以先进行修改，
   在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。
   乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。


7. 你建过索引吗? 建索引的原则
13.哪些字段适合作为索引。

    主键和外键必须有索引
    数据量过大一定要建索引
    经常锁join的表，join字段建索引
    where，groupBy, orderBy子句中的字段应建索引
    最好选择单调字段
    索引字段不宜过长
    经常以AND方式出现在Where子句中，单字段极少出现，建立复合索引
    复合索引包含的字段也经常出现在单字段查询中，则分解为单字段索引
    频繁进行数据的插入和删除的表，不要建太多索引

8. 索引的类型, 如主键索引
   主键索引：主键会自动建立索引,特殊的唯一索引，不允许null
   普通索引：表建好之后再建立的其他列的索引
   唯一索引：某列指定为unique时，就是唯一索引 create unique index on tableName (l1..)， 列值必须唯一，可以为null
   全文索引：它会把某个数据表的某个数据列上出现过的所有单词生成一份清单。
   组合索引：遵循最左前缀原理

6. mysql索引优化， 组合索引的最左前缀原则的含义？
    假设复合索引 index（ABC）
    全列匹配：ABC都有，可以触发索引
    最左前缀匹配（A， AB）：只会触发第一列A的索引
    中间空（AC）：也只会触发A索引， 这个时候建立AC辅助索引是比较好的
    没有第一列A（BC，B， C）：不会触发索引
    情况五：匹配某列的前缀字符串。会触发索引
    情况六：范围查询 只能触发一个范围索引，最左边的那个
    情况七：查询条件中含有函数或表达式。 无法使用索引

12.如何分析索引是否被命中。
14.哪些情况会导致索引无法命中。
9. 查看SQL执行计划
    explain

11.子查询与关联查询的区别
     子查询不需要两个表有关联字段，而连接查询必须有字段关联（所谓的主外键关系）
     子查询时，需要创建临时表,速度会受到一定的影响，这里多了一个创建和销毁临时表的过程。

2. sql优化有哪些着手点？
    开启查询缓存，重复对一个sql语句查询的时候，结果会被放到缓存中
    像curdate（）这样结果不固定的函数，sql不会开启缓存

    explain多用，查查你sql事怎么执行的

    索引优化

    select * 少用，会全表扫描，应该用什么就查什么

    尽量为每张表设置自增主键

    性别，国家，民族，状态，部门等有范围的字符串，用enum代替varchar

    多用limit分次查询，大量的insert和delete会锁表



15.一条很慢的sql,如何排查问题。慢查询

16.分库分表怎么分键
    分库
    随着数据量增加也许单台DB的存储空间不够，随着查询量的增加单台数据库服务器已经没办法支撑。这个时候就需要分数据库，
    常见的分库方式有：单库单表 -> 单库多表 -> 多库多表
    分库的优点是：实现简单，库与库之间界限分明，便于维护，缺点是不利于频繁跨库操作，单表数据量大的问题解决不了。

    分表
    纵向分表：根据数据的活跃度进行拆分，也就是按照字段使用活跃度来拆分。
    横向分表：把大的表结构，横向切割为同样结构的不同表，也就是同样的表按照某个业务规则复制很多个。
    分表的优点是：能解决分库的不足点，但是缺点却恰恰是分库的优点，分表实现起来比较复杂，
    特别是分表规则的划分，程序的编写，以及后期的数据库拆分移植维护。

    分数据
    号段分区：优点：可部分迁移 缺点：数据分布不均

    hash取模分区：数据分布均匀 缺点：数据迁移的时候麻烦，不能按照机器性能分摊数据


18.mysql的语句

19.存储过程
    什么是存储过程：存储过程可以说是一个记录集吧，它是由一些T-SQL语句组成的代码块，
    这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，
    在用到这个功能的时候调用他就行了。

    存储过程的好处：

    1.由于数据库执行动作时，是先编译后执行的。然而存储过程是一个编译过的代码块，所以执行效率要比T-SQL语句高。

    2.一个存储过程在程序在网络中交互时可以替代大堆的T-SQL语句，所以也能降低网络的通信量，提高通信速率。

    3.通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。

20. 缓存一致性

22.一致性哈希

23.mysql数据库数据导入oracle，如何保证数据一致性
   备份数据文件和日志文件

24.Mysql存储记录的数据结构
   表—段—区—页

25.自己设计一个唯一主键，多实例数据库表中ID唯一
   1.uuid：虽然可以解决唯一性，但是uuid太长了，严重影响mysql的写性能
   2.snowflake:这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，
   这种方案把64-bit分别划分成多段，分开来标示机器、时间等

   优点：
   毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
   不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
   可以根据自身业务特性分配bit位，非常灵活。

   缺点：
   强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。
   3.mysql自增主键方案
   对于MySQL性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，
   且步长和机器数相等。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11...）、
   TicketServer2的初始值为2（2，4，6，8，10...）
   缺点：
   系统水平扩展比较困难，

26.数据库的悲观锁和乐观锁 111

27.B+树在MySQL中一般有几层
   2~4层

28.聚簇索引（数据和主键一起存）和二级索引（叶子节点存储的是主键的值，然后通过主键的值再找具体数据）的加锁区别
   聚簇索引：只锁主键，因为主键索引都是唯一索引，只有一个
   二级索引：锁相关的键，即相同的键

29.一个表有id和mark两个字段，给定一个用户id，一个sql查出来他的排名
   select mark from table where id = ''

30.平常用到了什么索引优化，如何优化limit，如何优化or
   limit：select * from table_name limit 10000,10
          select * from table_name where (id >= 10000) limit 10
          select * from table_name where( user = xxx ) limit 10000,10
          select * from table_name Where id in (Select id From table_name where ( user = xxx )) limit 10000, 10;
          select * from table_name as a inner join ( select id from table_name where (user = xxx) limit 10000,10) as b on a.id = b.id
31.什么情况用聚集索引 什么情况用非聚集索引
   读操作多，用聚集索引
   写操作多，用非聚集索引
   涉及频繁的update的列最好用非聚集索引，因为频繁的update会频繁的改变索引结构

32.慢查询
   show_query_log = on
   long_query_time = 1
   show_query_log_file
   long_queries_not_using_indexes